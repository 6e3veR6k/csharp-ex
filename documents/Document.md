# Основы ООП для `.NET`


## Парадигмы ООП


ООП - Объектно-ориентированное программирование — парадигма программирования, в
которой основными концепциями являются понятия объектов и классов.

- Класс (лат. classis — группа) — группа предметов или явлений, обладающих общими
признаками.
- Класс — это конструкция языка, состоящая из ключевого слова class, идентификатора и тела.
Класс может содержать в своем теле поля и методы. Также классы могут включать в свое тело
другие классы, но такой подход не является широко распространённой техникой.
- Объект – это некоторая сущность, обладающая определённым состоянием и поведением,
имеет заданные значения свойств (полей) и операций над ними (методов).
- Объект состоит из следующих частей:
  1. имя объекта
  2. состояние (переменные состояния)
  3. методы (операции)

Объекты содержат в себе статические поля и все методы. Экземпляры содержат нестатические поля.

- Свойство — это способ доступа к внутреннему состоянию объекта, имитирующий переменную некоторого типа. Обращение к свойству объекта выглядит так же, как и обращение к структурному полю (в структурном программировании), но, в действительности, реализовано через вызов функции. При попытке задать значение данного свойства вызывается один метод, а при попытке получить значение данного свойства — другой.

- Экземпляр класса (instance) — это описание конкретного объекта в памяти.
- Инстанцирование (instantiation) — создание экземпляра класса. В отличие от слова «создание», применяется не к объекту, а к классу. То есть, говорят: «создать экземпляр класса или инстанцировать класс».

- Конструктор класса (constructor, иногда сокращают ctor) — специальный блок инструкций, вызываемый при создании объекта.

Конструкторы бывают двух типов:
  - конструктор без параметров - по-умолчанию.(Рекомендуется всегда создавать явно конструктор по умолчанию.)
  - конструктор с параметрами - пользовательский.(Рекомендуется использовать то же самое название для параметров конструктора и поля или свойства, если параметры конструктора используются для того чтобы инициализировать поле или установить свойство.)

Задача конструктора по умолчанию – инициализация полей значениями по умолчанию.

Задача пользовательского конструктора – инициализация полей предопределенными пользователем значениями.

Если в классе имеется пользовательский конструктор, и при этом требуется создавать экземпляры класса с использованием конструктора по умолчанию, то конструктор по умолчанию должен быть определен в теле класса явно, иначе возникнет ошибка на уровнекомпиляции.

- Конструктор не бывает виртуальным (в смысле как virtual).

- Рекомендуется минимизировать работу конструктора.

- Конструкторы бывают двух видов конструкторы типа и конструкторы экземпляра класса:
  - Конструкторы типа являются статическими и выполняются средой CLR до использования типа.
  - Конструкторы типа не могут принимать параметры.
  - Конструкторы экземпляра класса работают тогда, когда создается экземпляр класса.
  - Конструкторы экземпляра могут принимать параметры.
  - Конструкторы экземпляра  класса,  которые  не  принимают  параметров,  называют конструкторами по умолчанию.
  - Конструкторы экземпляра  класса,  которые  принимают  параметры,  называют пользовательскими конструкторами.

- CTS – Common Type System (Общая система типов) – это спецификация, определяющая, как
какой-либо тип должен быть определен для правильного выполнения средой .Net.

- Спецификация для CTS закреплена в стандарте Ecma 335, озаглавленном «Common Language
Infrastructure (CLI) Partitions I to VI». CLI и CTS были разработаны корпорацией Microsoft, а .NET
Framework — реализация этого стандарта.


- Ключевое слово readonly – это модификатор, который можно использовать для полей.
- Если созданное поле содержит модификатор readonly, присвоить значение такому полю можно только непосредственно в месте создания или в конструкторе в того же класса.
- Ключевое слово readonly отличается от ключевого слова const тем, что поле с модификатором const может быть инициализировано только при создании поля. Поле с модификатором readonly может быть инициализировано при создании или в конструкторе.
Следовательно, поля с модификатором readonly могут иметь различные значения в зависимости от использованного конструктора.


- Парадигма программирования – это система идей и понятий, определяющих стиль написания компьютерных программ, а также образ мышления программиста.

- К основным парадигмам ООП относятся:
  1. Инкапсуляция – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя.
  2. Наследование – это свойство системы, позволяющее описать новый класс на основе уже существующего.
  3. Полиморфизм – возможность объектов с одинаковой спецификацией иметь различную реализацию.
  4. Абстракция – это придание объекту характеристик, которые четко определяют его концептуальные границы, отличая от всех других объектов. Позволяет работать с объектами, не вдаваясь в особенности их реализации.
  5. Посылка сообщений – это способ передачи управления объекту. Если объект должен «отвечать» на это сообщение, то у него должен быть метод, соответствующий данному сообщению.
  6. Повторное использование – парадигма ООП в которой утверждается, что программы (компьютерная программа, программный модуль) частично либо полностью должны составляться из частей, написанных ранее компонентов и/или частей другой программы (системы). Это основная методология, которая применяется для сокращения трудозатрат при разработке сложных систем.

> Задачи
1. Создать класс с именем Address. В теле класса требуется создать поля: index, country, city, street, house, apartment. Для каждого поля, создать свойство с двумя методами доступа. Создать экземпляр класса Address. В поля экземпляра записать информацию о почтовом адресе. Выведите на экран значения полей, описывающих адрес.
2. Создать класс с именем Rectangle. В теле класса создать два поля, описывающие длины сторон  double side1, side2. Создать пользовательский конструктор  Rectangle(double side1, double side2) , в теле которого поля  side1 и side2 инициализируются значениями аргументов. Создать два метода, вычисляющие площадь прямоугольника -  double AreaCalculator() и периметр прямоугольника -  double PerimeterCalculator(). Создать два свойства  double Area и double Perimeter с одним методом доступа get. Написать программу, которая принимает от пользователя длины двух сторон прямоугольника и выводит на экран периметр и площадь.
3. Создать класс Book. Создать классы Title, Author и Content, каждый из которых должен содержать одно строковое поле и метод  void Show(). Реализуйте возможность добавления в книгу названия книги, имени автора и содержания. Выведите на экран разными цветами при помощи метода Show() название книги, имя автора и содержание.
4. Создать классы Point и Figure. Класс Point должен содержать два целочисленных поля и одно строковое поле. Создать три свойства  с одним методом доступа get. Создать пользовательский конструктор, в теле которого проинициализируйте поля значениями аргументов. Класс Figure должен содержать конструкторы, которые принимают от 3-х до 5-ти аргументов типа Point. Создать два метода:  double LengthSide(Point A, Point B), который рассчитывает длину стороны многоугольника; void PerimeterCalculator(), который рассчитывает периметр многоугольника. Написать программу, которая выводит на экран название и периметр многоугольника.
5. Создать класс  Converter. В теле класса создать пользовательский конструктор, который принимает три вещественных аргумента,
и инициализирует поля соответствующие курсу 3-х основных валют, по отношению к гривне –  public Converter(double usd, double eur, double rub). Написать программу, которая будет выполнять конвертацию из гривны в одну из указанных валют, также программа должна производить конвертацию из указанных валют в гривну.
6. Создать класс  Employee. В теле класса создать пользовательский конструктор, который принимает два строковых аргумента, и инициализирует поля, соответствующие фамилии и имени сотрудника. Создать метод рассчитывающий оклад сотрудника (в зависимости от должности и стажа) и налоговый сбор. Написать программу, которая выводит на экран информацию о сотруднике (фамилия, имя, должность), оклад и  налоговый сбор.
7. Создать класс  Invoice. В теле класса создать три поля  int account ,  string customer ,  string provider , которые должны быть проинициализированы один раз (при создании экземпляра данного класса) без возможности их дальнейшего изменения. В теле класса создать два закрытых поля  string article, int quantity. Создать метод расчета стоимости заказа с НДС и без НДС. Написать программу, которая выводит на экран сумму оплаты заказанного товара с НДС или без НДС.


### Инкапсуляция

Инкапсуляция (инкапсуляция вариаций) – техника сокрытия частей объектно-ориентированных программных систем.

### Наследование

ООП — Объектно-ориентированное программирование — парадигма программирования, в
которой основными концепциями являются понятия объектов и классов.
- Наследование — механизм  объектно-ориентированного  программирования  (наряду  с
инкапсуляцией, полиморфизмом и абстракцией), позволяющий описать новый класс на основе
уже существующего (родительского), при этом свойства и функциональность родительского
класса заимствуются новым классом.
- Недостаток наследования – хрупкий базовый класс. Хрупкий базовый класс — фундаментальная
проблема объектно-ориентированного программирования. Проблема хрупкого базового класса
заключается в том, что малейшие правки в деталях реализации базового класса могут
привнести ошибку в производные классы. В худшем случае это приводит к тому, что любая
успешная модификация базового класса требует предварительного изучения всего дерева
наследования, и зачастую невозможна (без создания ошибок) даже в этом случае.
- Рекомендуется использовать следующие пары:
Базовый класс – Производный класс
Супер класс – Подкласс или (сабкласс)
Родительский класс – Дочерний класс
Класс Родитель – Класс Потомок
- Модификаторы доступа – это ключевые слова, задающие объявленную доступность члена или
типа. При помощи модификаторов доступа можно задать следующие пять уровней доступности:
1) public — доступ к типу или члену возможен из любого другого кода в той же сборке или
другой сборке, ссылающейся на него.
2) protected — доступ к типу или элементу можно получить только из кода в том же классе,
либо в производном классе.
3) internal — доступ к типу или члену возможен из любого кода в той же сборке, но не из
другой сборки.
4) protected internal — доступ ограничен текущей сборкой или типами, которые являются
производными от содержащего класса.
5) private — доступ к типу или члену можно получить только из кода в том же классе или
структуре.
- Полиморфизм — возможность объектов с одинаковой спецификацией иметь различную
реализацию.
- Полиморфизм предоставляет подклассу способ определения собственной версии
метода, определенного в его базовом классе, с использованием процесса, который
называется переопределением метода (method overriding).
- Базовые классы могут определять и реализовывать виртуальные методы, а производные
классы могут переопределять их. Это означает, что они предоставляют свои собственные
определение и реализацию.
- Во время выполнения, когда клиентский код вызывает метод, среда CLR ищет тип времени
выполнения объекта и вызывает это переопределение виртуального метода. Таким образом, в
исходном коде можно вызвать метод в базовом классе и вызвать выполнение метода с версией
производного класса.
- Если производный класс наследует от базового класса, то он приобретает все методы, поля,
свойства и события базового класса. Проектировщик производного класса может выбирать из
следующих возможностей:
1) переопределить виртуальные члены в базовом классе
2) наследовать метод последнего базового класса без его переопределения
3) определить новую не виртуальную реализацию этих членов, которая скрывает реализации
базового класса.
- Поля не могут быть виртуальными.
- Виртуальными могут быть только методы, свойства, события и индексаторы.
- Если в производном классе виртуальный метод переопределяется, то этот член вызывается
даже в том случае, если доступ к экземпляру этого класса осуществляется как к экземпляру
базового класса.
- Виртуальные методы и свойства дают возможность производным классам расширять базовый
класс, без необходимости использования реализации метода базового класса.
- Если необходимо, чтобы производный член имел то же имя, что и член базового класса, но не
нужно, чтобы он участвовал в виртуальном вызове, можно использовать ключевое слово new.
Ключевое слово new располагается перед возвращаемым типом замещаемого члена класса.
- Оператор is - проверяет совместимость объекта с заданным типом.
- Если предоставленный объект может быть приведен к предоставленному типу не вызывая
исключение, выражение is принимает значение true.
- Оператор as используется для выполнения преобразований между совместимыми ссылочными
типами
- Оператор as подобен оператору приведения. Однако, если преобразование невозможно, as
возвращает значение null, а не вызывает исключение
- В общем виде логика работы оператора as представляет собой механизм использования
оператора is, только в сокращенном виде
- Ключевое слово — sealed, которое предотвращает наследование. Если класс помечен как
sealed (запечатанный), компилятор не позволяет наследовать от него. Считается, что класс
герметизирован или «запечатан».


> Задачи
1. Создайте класс  Printer. В теле класса создайте метод  void Print(string value) , который выводит на экран значение аргумента. Реализуйте возможность того, чтобы в случае наследования от данного класса других классов, и вызове соответствующего метода их экземпляра, строки, переданные в качестве аргументов методов, выводились разными цветами. Обязательно используйте приведение типов.
2. Создать класс, представляющий учебный класс ClassRoom.
Создайте класс ученик Pupil. В теле класса создайте методы  void Study() ,  void Read() ,  void
Write() ,  void Relax() .
Создайте 3 производных класса ExcelentPupil, GoodPupil, BadPupil от класса базового класса
Pupil и переопределите каждый из методов, в зависимости от успеваемости ученика.
Конструктор класса ClassRoom принимает аргументы типа Pupil, класс должен состоять из 4 учеников.
Предусмотрите возможность того, что пользователь может передать 2 или 3 аргумента.
Выведите информацию о том, как все ученики экземпляра класса ClassRoom умеют учиться, читать,
писать, отдыхать.
3. В теле класса создайте поля: координаты и параметры средств передвижения (цена, скорость, год
выпуска).
Создайте 3 производных класса Plane, Саг и Ship.
Для класса Plane должна быть определена высота и количество пассажиров.
Для класса Ship — количество пассажиров и порт приписки.
Написать программу, которая выводит на экран информацию о каждом средстве передвижения.
4. Создайте класс  DocumentWorker .
В теле класса создайте три метода  OpenDocument(), EditDocument(), SaveDocument(). В тело каждого из методов добавьте вывод на экран соответствующих строк:  "Документ открыт",
"Редактирование документа доступно в версии Про", "Сохранение документа доступно в
версии Про".
Создайте производный класс  ProDocumentWorker.
Переопределите соответствующие методы, при переопределении методов выводите следующие строки:
"Документ отредактирован", "Документ сохранен в старом формате, сохранение в остальных
форматах доступно в версии Эксперт".
Создайте производный класс  ExpertDocumentWorker  от базового класса ProDocumentWorker.
Переопределите соответствующий метод. При вызове данного метода необходимо выводить на экран
"Документ сохранен в новом формате".
В теле метода Main()  реализуйте возможность приема от пользователя номера ключа доступа pro и exp.
Если пользователь не вводит ключ, он может пользоваться только бесплатной версией (создается
экземпляр базового класса), если пользователь ввел номера ключа доступа pro и exp, то должен
создаться экземпляр соответствующей версии класса, приведенный к базовому –  DocumentWorker.

### Полиморфизм


### Абстракция

- Абстракция – в объектно-ориентированном программировании это придание объекту
характеристик, которые отличают его от всех других объектов, четко определяя его
концептуальные границы. Основная идея состоит в том, чтобы отделить способ использования
составных объектов данных от деталей их реализации, в виде более простых объектов, подобно
тому, как функциональная абстракция разделяет способ использования функции и деталей её
реализации, в терминах более примитивных функций, таким образом, данные обрабатываются
функцией высокого уровня с помощью вызова функций низкого уровня.
- Абстрактный класс в объектно-ориентированном программировании – базовый класс, который
не предполагает создания экземпляров. Абстрактные классы реализуют на практике один из
принципов ООП - полиморфизма. Абстрактный класс может содержать (и не содержать)
абстрактные методы и свойства. Абстрактный метод не реализуется для класса, в котором
описан, однако должен быть реализован для его неабстрактных потомков. Абстрактные классы
представляют собой наиболее общие абстракции, то есть имеющие наибольший объем и
наименьшее содержание.
- Ключевое слово abstract может использоваться с классами, методами, свойствами,
индексаторами и событиями.
- Ключевое слово abstract при создании класса указывает, что класс предназначен только для
использования в качестве базового класса для других классов. Члены, помеченные как
абстрактные или включенные в абстрактный класс, должны быть реализованы с помощью
классов, производных от абстрактных классов.
- Возможности абстрактных классов:
- Экземпляр абстрактного класса создать нельзя
- Абстрактные классы могут содержать как абстрактные, так и обыкновенные (неабстрактные)
члены.
- Неабстрактный класс, являющийся производным от абстрактного, должен содержать
фактические реализации всех наследуемых абстрактных методов и методов доступа.
- Возможности абстрактных методов:
- Абстрактный метод является неявным виртуальным методом.
- Создание абстрактных методов допускается только в абстрактных классах.
- Тело абстрактного метода отсутствует; создание метода просто заканчивается точкой с
запятой, а после сигнатуры ставить фигурные скобки ({ }) не нужно
- Реализация предоставляется методом переопределения override, который является членом
неабстрактного класса.
- Абстрактный класс должен предоставлять реализацию для всех членов интерфейса.
- Абстрактный класс, реализующий интерфейс, может отображать методы интерфейса в
абстрактных методах.
- Преимущества использования абстрактных классов:
- Общий код в одной реализации в виде конкретных и абстрактных членов
- Изменение значения полей или неабстрактных членов абстрактного класса приводит к
соответствующему изменению во всех его производных классах.
- Наличие реализации по умолчанию.
- Интерфейс (от лат. inter – «между», и face – «поверхность») – семантическая и синтаксическая
конструкция в коде программы, используемая для специфицирования услуг, предоставляемых
классом или компонентом. Интерфейс определяет границу взаимодействия между классами
или  компонентами,  специфицируя  определенную  абстракцию,  которую  осуществляет
реализующая сторона. В отличие от многих других видов интерфейсов, интерфейс в ООП
является строго формализованным элементом объектно-ориентированного языка и, в качестве
семантической конструкции, широко используется кодом программы.
- Невозможно создать экземпляр интерфейса.
- Интерфейсы и члены интерфейсов являются абстрактными. Интерфейсы не имеют реализации
по умолчанию.
- Интерфейс содержит только сигнатуры методов, свойств, событий или индексаторов.
- Члены интерфейсов автоматически являются открытыми, абстрактными, и они не могут иметь
модификаторы доступа.
- Интерфейсы не могут содержать константы, поля, операторы, конструкторы экземпляров,
деструкторы или типы.
- Класс или структура, которые реализуют интерфейс, должны реализовать члены этого
интерфейса, указанные при его создании.
- Однако если базовый класс реализует интерфейс, производный также класс наследует эту
реализацию.
- Интерфейс может наследоваться от одного или нескольких базовых интерфейсов.
- Базовый класс также может реализовать члены интерфейса с помощью виртуальных членов. В
этом  случае  производный  класс  может  изменить  поведение  интерфейса  путем
переопределения виртуальных членов.
- Если класс реализует два интерфейса, содержащих член с одинаковой сигнатурой, то при
реализации этого члена в классе оба интерфейса будут использовать этот член для своей
реализации.
- Если члены двух интерфейсов с одинаковой сигнатурой методов должны выполнять различные
действия при их реализации, необходимо воспользоваться явной реализацией члена
интерфейса – техникой явного указания в имени члена имени интерфейса, которому
принадлежит данный член. Это достигается путем включения в имя члена класса имени
интерфейса с точкой. Данный член в производном классе будет помечен по умолчанию как
скрытый.
- Преимущество использования интерфейсов:
- Класс или структура может реализовать несколько интерфейсов.
- Если класс или структура реализует интерфейс, она получает только имена и сигнатуры
метода
- Интерфейсы определяют поведение экземпляров производных классов
- Базовый класс может обладать ненужным функционалом, полученным от других его
базовых классов, чего можно избежать, применяя интерфейсы
• Внедрение зависимостей (Dependency Injection, DI) – превосходная методика для создания
слабосвязанных приложений. Она предоставляет возможности для упрощения кода, извлечения
и обработки зависимостей между объектами и автоматического создания экземпляров
зависимого объекта.
• Внедрение зависимостей описывает процесс разработки приложений – вместо указания
конкретных зависимостей в приложении во время разработки и создания необходимых
объектов в коде во время выполнения приложение решает, какие объекты ему требуются, а
потом создает и внедряет их в приложение.
• Использование внедрения зависимостей предоставляет несколько преимуществ:
- Ослабление связи между классами
- Создание кода, который лучше поддается проверке.
- Упрощение тестирования.


> Задачи
1. Создайте класс  AbstractHandler.
В теле класса создать методы  void Open(), void Create(), void Chenge(), void Save().
Создать производные классы  XMLHandler, TXTHandler, DOCHandler от  базового  класса
AbstractHandler.
Написать программу, которая будет выполнять определение документа и для каждого формата
должны быть методы открытия, создания, редактирования, сохранения определенного
формата документа.

2. Создайте 2 интерфейса IPlayable и IRecodable. В каждом из интерфейсов создайте по 3
метода  void Play() / void Pause() / void Stop() и void Record() / void Pause() / void Stop()
соответственно.
Создайте производный класс  Player от базовых интерфейсов IPlayable и IRecodable.
Написать программу, которая выполняет проигрывание и запись.
